#回顾Linux内核后门

#摘要
由于最近大众对美国国家安全局（NSA）的关注，人们的注意力转移到后门程序的可能性上。在2003年时曾有人试图向Linux内核中植入后门，虽然被发现了，但是这表明不论看上去多普通的变更都会引入漏洞，以及源码控制管理的重要性。

----------------------

由于最近大众对美国国家安全局（NAS）的关注，人们的注意力转移到后门程序上。对于不熟悉该术语的人们，后门是一种有意在操作系统或软件中植入的漏洞，允许未授权的用户访问系统。在2003年曾经有人试图向Linux内核植入后门，虽然被发现了，但是这表明不论看上去多普通的变更都会引入漏洞，以及源码控制管理的重要性。

Corbet在[LVN.Net](https://lwn.net/Articles/57135/)的文章中首次提到以下这段代码，它把自己伪装成类似[wait4](http://linux.die.net/man/2/wait4)函数的参数校验。

    if((options == (__WCLONE|__WALL)) && (current->uid = 0))
        retval = -EINVAL;

正常情况下没有任何影响，但是如果调用程序故意传入非法值，if表达式的第二部分就会执行。该部分会将程序的用户ID（current->uid）设为0,在Linux中就是root用户。

一眼看上去这就像是一个简单的代码错误，开发人员经常疏忽将'=='写成'='。虽然你认为函数wait4不应该与用户ID有任何关系，但是很明显这是故意为为之。

Corbet描述了该后门是如何被发现的，
>CVS库中的每个变更都会包含反向链接信息，表明与BitKeeper中的变更相同。有问题的变更缺少这样的信息，所以很快就能辨认出来。

>试图通过这种方式进行变更是很可疑的，至少可以这么说，所以我们非常关注变更请求到底是什么。

攻击者曾经再次向BitKeeper库的CVS克隆库中植入后门。他继续说道，
>CVS代码库是从BitKeeper生成的，但是补丁程序进入BitKeeper代码库并不经过它。所以有问题的代码只会影响基于CVS代码库工作的用户。发行商使用的内核不是来自该库，这次事故也说明，问题代码能够驻留很长一段时间。

大家想象一下，如果有人向代码库发起这样的攻击，增加几行看上去很好的代码，实际上植入了一个后门，而代码库没有Linux内核团队的控制和严格检查，你如何保护自己不受攻击。

一种方式是在应用程序中创建自己的“内核”，只有这段代码可以改变用户的角色和权限。其他的代码只是获取到用户权限的只读视图，这样他们就不能轻易得获取root权限。

在这样的模型中，"current->uid=0"这样的代码不会编译。如果任何人想实施攻击，或是直接修改应用程序的安全模块，但是我们会密切关注这样的修改，或是使用反射的伎俩，但是反射代码肯定比简单的赋值操作更容易被察觉到。

如果语言层面支持，一种更好的方式是使用户权限完全不可变。这种方式能够更大程度限制攻击发生的地方，只能是创建权限的地方。

这些措施应该配合对源码控制服务器的限制进行实施。一是限制尽可能少的人向主分支中提交代码，而不是过于开放；二是安全敏感代码默认应该完全锁定，只能根据问题具体情况授予编辑权限，实施的具体方法依赖此人是否使用分布式或集中式的源码控制以及具体的产品。

如果没有在变更代成为产品之前进行审计，最终这些技术都会失效，这些措施只能减少审计疏漏问题发生的可能性。
